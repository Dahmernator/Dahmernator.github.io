<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hockey Sprite Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1a1a2e; /* Dark background */
            font-family: sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #34495e; /* Rink-ish color */
            border: 5px solid #ffffff;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            /* Keeps your 64px sprite from looking blurry */
            image-rendering: pixelated; 
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="500"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 1. Setup the Player Object
        const player = {
            img: new Image(),
            // Ensure this file name matches your GitHub file EXACTLY
            src: 'red-hockey-guy64.png', 
            x: 370,
            y: 220,
            width: 64,
            height: 64,
            speed: 8,
            facingLeft: false,
            isLoaded: false
        };

        // 2. Load the Image
        player.img.onload = () => {
            player.isLoaded = true;
            draw(); // Draw once it's ready
        };
        player.img.src = player.src;

        // 3. The Main Drawing Function
        function draw() {
            // Clear the entire canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Optional: Draw a simple floor or "ice" lines
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 50, 700, 400);

            if (player.isLoaded) {
                // We use save/restore to flip without affecting the whole world
                ctx.save(); 

                if (player.facingLeft) {
                    // FLIP LOGIC: Translate to player position + width, then scale -1
                    ctx.translate(player.x + player.width, player.y);
                    ctx.scale(-1, 1);
                    // Draw at 0,0 because translate moved our "pen"
                    ctx.drawImage(player.img, 0, 0, player.width, player.height);
                } else {
                    // NORMAL DRAW:
                    ctx.drawImage(player.img, player.x, player.y, player.width, player.height);
                }

                ctx.restore(); 
            }
        }

        // 4. Keyboard Controls
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                    player.x -= player.speed;
                    player.facingLeft = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    player.x += player.speed;
                    player.facingLeft = false;
                    break;
                case 'ArrowUp':
                case 'w':
                    player.y -= player.speed;
                    break;
                case 'ArrowDown':
                case 's':
                    player.y += player.speed;
                    break;
            }
            
            // Redraw everything whenever a key is pressed
            draw();
        });

    </script>
</body>
</html>