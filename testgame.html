<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hockey Animation - Two Frames</title>
    <style>
        body { margin: 0; background: #1a1a2e; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #e3f2fd; border: 5px solid #fff; image-rendering: pixelated; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="960" height="640"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const player = {
            color: '#ffff22',
            x: 370,
            y: (640 - 64) / 2, // center vertically
            width: 64,
            height: 64,
            vx: 0,
            accel: 500,
            friction: 0.96,
            maxSpeed: 600,
            facingLeft: false
        };

        const rink = {
            img: new Image(),
            y: 0,
            vy: 0,
            scaledHeight: 0
        };
        rink.img.src = 'hockey-rink.png';
        rink.img.onload = () => {
            // scale rink to canvas width
            rink.scaledHeight = 1920
            // start with rink centered so player appears over center
            if (rink.scaledHeight > canvas.height) {
                rink.y = 1140;
            } else {
                rink.y = 0;
            }
        };

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        let lastTime = 0;
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        function gameLoop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (dt > 0.1) dt = 0.1;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            let isMoving = false;

            // Horizontal movement moves the player
            if (keys['ArrowLeft'] || keys['a']) { player.vx -= player.accel * dt; player.facingLeft = true; isMoving = true; }
            if (keys['ArrowRight'] || keys['d']) { player.vx += player.accel * dt; player.facingLeft = false; isMoving = true; }

            // Vertical input moves the rink (so player stays vertically fixed)
            if (keys['ArrowUp'] || keys['w']) { rink.vy += player.accel * dt; isMoving = true; }
            if (keys['ArrowDown'] || keys['s']) { rink.vy -= player.accel * dt; isMoving = true; }

            // Apply friction / update player horizontal
            player.vx *= player.friction;
            if (Math.abs(player.vx) < 0.01) player.vx = 0;
            player.x += player.vx * dt;
            if (player.x < 80) player.x = 80;
            if (player.x + player.width > 880) player.x = 880 - player.width;

            rink.vy *= player.friction;
            if (Math.abs(rink.vy) < 0.01) rink.vy = 0;
            
            rink.y += rink.vy * dt;

            let middleY = canvas.height / 2 - player.width / 2;
            if(rink.y <= 640 && rink.vy < 0){
                let diff = 640 - rink.y;
                rink.y = 640;
                player.y += diff;
            }else if(rink.y >= 1920 && rink.vy > 0){
                let diff = rink.y - 1920;
                rink.y = 1920;
                player.y -= diff;
            }
            if(player.y > middleY && rink.vy > 0){
                rink.y = 640;
                player.y -= rink.vy * dt;
                if(player.y < middleY){
                    let diff = middleY - player.y;
                    player.y = middleY;
                    rink.y += diff;
                }
            }else if(player.y < middleY && rink.vy < 0){
                rink.y = 1920 
                player.y -= rink.vy * dt;
                if(player.y > middleY){
                    let diff = player.y - middleY;
                    player.y = middleY;
                    rink.y -= diff;
                }
            }
            if(player.y < 80){
                player.y = 80;
                rink.vy = 0;
            }else if(player.y + player.width > 560){
                player.y = 560 - player.width;
                rink.vy = 0;
            }
            console.log(player.x, player.y, rink.y);
            // x pos is player.x, y pos is rink.y-player.y

            
                

            
           //rink goes from x=80 to 880 and y goes from 80&1920 to 560&640, screen.y and rink.y    
            // find the closest corner the center of the player is at, center of the corners are at 
            // see if they are > 224 - 1/2 width of player from the center of the circle
            // if so put their center within the 224 - 1/2 width on the line that intersects the center of the circle and the center of the player
            // update their velocity and momentum 
            let collisionVelocityDeminisher = 0.9; // how much velocity is lost when colliding with the circle, 0.9 means 10% velocity is lost
            // Top-left circle collision
            if(player.y < 288 && player.x < 80 + 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 80+224, 80+224) > 224 - player.width/2){
                console.log("Colliding with top-left circle");
                let angle = Math.atan2(player.y + player.width/2 - (80+224), player.x + player.width/2 - (80+224));
                player.x = 80 + 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 80 + 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y < 288 && player.x > 880 - 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 880-224, 80+224) > 224 - player.width/2){
                console.log("Colliding with top-right circle");
                let angle = Math.atan2(player.y + player.width/2 - (80+224), player.x + player.width/2 - (880-224));
                player.x = 880 - 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 80 + 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y > 288 && player.x < 80 + 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 80+224, 640-80-224) > 224 - player.width/2){
                console.log("Colliding with bottom-left circle");
                let angle = Math.atan2(player.y + player.width/2 - (640-80-224), player.x + player.width/2 - (80+224));
                player.x = 80 + 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 640 - 80 - 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y > 288 && player.x > 880 - 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 880-224, 640-80-224) > 224 - player.width/2){
                console.log("Colliding with bottom-right circle");
                let angle = Math.atan2(player.y + player.width/2 - (640-80-224), player.x + player.width/2 - (880-224));
                player.x = 880 - 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 640 - 80 - 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }
        }

        function drawRink() {
            if (!rink.img.complete) return;
            const h = rink.scaledHeight || canvas.height;
            ctx.drawImage(rink.img, 0, 0, rink.img.width, rink.img.height, 0, rink.y - h, canvas.width, h);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw rink first
            drawRink();
            
            // Draw arc for corner circle
            ctx.beginPath();
            ctx.arc(80+224, 80+224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(880-224, 80+224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(80+224, 640-80-224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(880-224, 640-80-224, 224-32, 0, 2 * Math.PI, false);

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.save();
                ctx.fillStyle = player.color;
                // draw a square player (player.width x player.width)
                if (player.facingLeft) {
                    ctx.translate(player.x + player.width, player.y);
                    ctx.scale(-1, 1);
                    ctx.fillRect(0, 0, player.width, player.width);
                } else {
                    ctx.fillRect(player.x, player.y, player.width, player.width);
                }
            ctx.restore();
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
