<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hockey Animation - Two Frames</title>
    <style>
        body { margin: 0; background: #1a1a2e; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background: #e3f2fd; border: 5px solid #fff; image-rendering: pixelated; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="960" height="640"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const player = {
            color: '#ffff22',
            x: 370,
            y: (640 - 64) / 2, // center vertically
            width: 64,
            height: 64,
            vx: 0,
            vy: 0,
            accel: 600,
            friction: 0.96,
            maxSpeed: 650,
            facingLeft: false
        };

        const rink = {
            img: new Image(),
            y: 0,
            vy: 0,
            scaledHeight: 0
        };
        rink.img.src = 'hockey-rink.png';
        rink.img.onload = () => {
            // scale rink to canvas width
            rink.scaledHeight = 1920
            // start with rink centered so player appears over center
            if (rink.scaledHeight > canvas.height) {
                rink.y = 1140;
            } else {
                rink.y = 0;
            }
        };

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        let lastTime = 0;
        function distance(x1, y1, x2, y2) {// performs distance formula for 2 coordinates given
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        function gameLoop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (dt > 0.1) dt = 0.1;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }
        function checkXBounds(currPlayer){// forces player within 80 & 880, the boundary for the rink
            if(currPlayer.x < 80){// will need to add x + radius
                currPlayer.x = 80;
            }
            if(currPlayer.x + player.width > 880){// will work same for radius
                currPlayer.x = 880 - player.width;
            }
        }
        function checkYBounds(currPlayer, dt){
            let middleY = (canvas.height - player.width) / 2;// will be canvas.height/2 - radius
            console.log(player.y);
            if(rink.y < 640){// moves player down when at bottom of rink
                let diff = 640 - rink.y;
                player.y += diff;
                rink.y = 640;
            }else if(rink.y > 1920){// moves player up when at top of rink
                let diff = rink.y - 1920;
                player.y -= diff;
                rink.y = 1920;
            }
            if(player.y > middleY && rink.vy > 0 && rink.y < 1000){// moves player up when rink is locked at bottom
                rink.y = 640;
                player.y -= rink.vy * dt;
                if(player.y < middleY){
                    let diff = player.y - middleY;
                    player.y = 288;
                    rink.y -= diff;
                }
            }
            if(player.y < middleY && rink.vy < 0){// moves player down when rink is locked at top
                rink.y = 1920;
                player.y -= rink.vy * dt
                if(player.y > middleY){
                    let diff = player.y - middleY;
                    player.y = 288;
                    rink.y += diff;
                }
            }
            if(player.y < 80){// prevents player from exiting rink at top
                player.y = 80;
                rink.vy = 0;
            }else if(player.y + player.width > 560){// prevents player from exiting rink at bottom
                player.y = 560 - player.width;
                rink.vy = 0;
            }
                

        }
        function moveCurrentPlayer(currPlayer, xMov, yMov, dt){
            currPlayer.vx += currPlayer.accel * xMov * dt;// changes velo with accel, player direction, and dt
            currPlayer.vy += currPlayer.accel * yMov * dt;
            currPlayer.vx *= currPlayer.friction;// demishes velo with friction
            currPlayer.vy *= currPlayer.friction;
            rink.vy = currPlayer.vy;
            if(Math.abs(currPlayer.vx) < 0.01){// if really small vx, make it 0
                currPlayer.vx = 0;
            }
            if(Math.abs(currPlayer.vy) < 0.01){// if really small vy, make it 0
                currPlayer.vy = 0;
            }
            currPlayer.x += currPlayer.vx * dt;
            rink.y += rink.vy * dt;
            //currPlayer.y += currPlayer.vy * dt; hold off for now cause we also have to move the rink opposite in sync w/ player
            checkXBounds(currPlayer);
            checkYBounds(currPlayer, dt);
        }
        function update(dt) {
            let currentPlayer = player;
            let xMov = 0;
            let yMov = 0;
            let sqrtPoint5 = 0.707;
            // Horizontal movement moves the player
            if (keys['ArrowLeft'] || keys['a']) {
                xMov -= 1;
            }
            if (keys['ArrowRight'] || keys['d']) {
                xMov += 1;
            }
            // Vertical input moves the rink (so player stays vertically fixed)
            if (keys['ArrowUp'] || keys['w']){
                yMov += 1;
            }
            if (keys['ArrowDown'] || keys['s']){
                yMov -= 1;
            }
            // if moving in x & y direction, move 1 unit diagonally
            if(xMov * yMov != 0){// mults moving direction by sqrt(0.5) if moving diagonally
                xMov *= sqrtPoint5;
                yMov *= sqrtPoint5;
            }

            moveCurrentPlayer(currentPlayer, xMov, yMov, dt); //rn does physics equations and checks x bounds
            
           //rink goes from x=80 to 880 and y goes from 80&1920 to 560&640, screen.y and rink.y    
            // find the closest corner the center of the player is at, center of the corners are at 
            // see if they are > 224 - 1/2 width of player from the center of the circle
            // if so put their center within the 224 - 1/2 width on the line that intersects the center of the circle and the center of the player
            // update their velocity and momentum 
            let collisionVelocityDeminisher = 0.9; // how much velocity is lost when colliding with the circle, 0.9 means 10% velocity is lost
            // Top-left circle collision
            if(player.y < 288 && player.x < 80 + 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 80+224, 80+224) > 224 - player.width/2){
                console.log("Colliding with top-left circle");
                let angle = Math.atan2(player.y + player.width/2 - (80+224), player.x + player.width/2 - (80+224));
                player.x = 80 + 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 80 + 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y < 288 && player.x > 880 - 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 880-224, 80+224) > 224 - player.width/2){
                console.log("Colliding with top-right circle");
                let angle = Math.atan2(player.y + player.width/2 - (80+224), player.x + player.width/2 - (880-224));
                player.x = 880 - 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 80 + 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y > 288 && player.x < 80 + 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 80+224, 640-80-224) > 224 - player.width/2){
                console.log("Colliding with bottom-left circle");
                let angle = Math.atan2(player.y + player.width/2 - (640-80-224), player.x + player.width/2 - (80+224));
                player.x = 80 + 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 640 - 80 - 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }else if(player.y > 288 && player.x > 880 - 224 - player.width/2 && distance(player.x + player.width/2, player.y + player.width/2, 880-224, 640-80-224) > 224 - player.width/2){
                console.log("Colliding with bottom-right circle");
                let angle = Math.atan2(player.y + player.width/2 - (640-80-224), player.x + player.width/2 - (880-224));
                player.x = 880 - 224 + Math.cos(angle) * (224 - player.width/2) - player.width/2;
                player.y = 640 - 80 - 224 + Math.sin(angle) * (224 - player.width/2) - player.width/2;
                // add velocity in the direction away from the center of the circle
                let speed = distance(0, 0, player.vx, player.vy) * collisionVelocityDeminisher;
                let newVx = Math.cos(angle) * speed;
                let newVy = Math.sin(angle) * speed;
                // if the new velocity is less than the old velocity, use the new velocity
                if(distance(0, 0, newVx, newVy) < distance(0, 0, player.vx, player.vy)){
                    player.vx = newVx;
                    player.vy = newVy;
                }
            }
        }

        function drawRink() {
            if (!rink.img.complete) return;
            const h = rink.scaledHeight || canvas.height;
            ctx.drawImage(rink.img, 0, 0, rink.img.width, rink.img.height, 0, rink.y - h, canvas.width, h);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw rink first
            drawRink();
            
            // Draw arc for corner circle
            ctx.beginPath();
            ctx.arc(80+224, 80+224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(880-224, 80+224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(80+224, 640-80-224, 224-32, 0, 2 * Math.PI, false);
            ctx.arc(880-224, 640-80-224, 224-32, 0, 2 * Math.PI, false);

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.save();
                ctx.fillStyle = player.color;
                // draw a square player (player.width x player.width)
                if (player.facingLeft) {
                    ctx.translate(player.x + player.width, player.y);
                    ctx.scale(-1, 1);
                    ctx.fillRect(0, 0, player.width, player.width);
                } else {
                    ctx.fillRect(player.x, player.y, player.width, player.width);
                }
            ctx.restore();
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
